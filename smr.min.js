(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.smr=f()}})(function(){var define,module,exports;return function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}({1:[function(require,module,exports){module.exports=function(A){var rows=A.length;var columns=A[0].length;var lead=0;for(var k=0;k<rows;k++){if(columns<=lead)return;var i=k;while(A[i][lead]===0){i++;if(rows===i){i=k;lead++;if(columns===lead)return}}var irow=A[i],krow=A[k];A[i]=krow,A[k]=irow;var val=A[k][lead];for(var j=0;j<columns;j++){A[k][j]/=val}for(var i=0;i<rows;i++){if(i===k)continue;val=A[i][lead];for(var j=0;j<columns;j++){A[i][j]-=val*A[k][j]}}lead++}return A}},{}],2:[function(require,module,exports){"use strict";var rref=require("rref");function MatrixProduct(options){this.product=squareMatrix(options)}MatrixProduct.prototype.addRowAndColumn=function(options){for(var c=0;c<options.lhsColumn.length;c++)for(var r=0;r<options.rhsRow.length;r++)this.product[c][r]+=options.lhsColumn[c]*options.rhsRow[r]};MatrixProduct.prototype.push=MatrixProduct.prototype.addRowAndColumn;function Regression(options){if(!options)throw new Error("missing options");if(!("numX"in options))throw new Error("you must give the width of the X dimension as the property numX");if(!("numY"in options))throw new Error("you must give the width of the X dimension as the property numY");this.transposeOfXTimesX=new MatrixProduct({numRows:options.numX,numColumns:options.numX});this.transposeOfXTimesY=new MatrixProduct({numRows:options.numX,numColumns:options.numY});this.identity=identity(options.numX)}Regression.prototype.addObservation=function(options){if(!options)throw new Error("missing options");if(!(options.x instanceof Array)||!(options.y instanceof Array))throw new Error("x and y must be given as arrays");this.transposeOfXTimesX.addRowAndColumn({lhsColumn:options.x,rhsRow:options.x});this.transposeOfXTimesY.addRowAndColumn({lhsColumn:options.x,rhsRow:options.y});delete this.coefficients};Regression.prototype.push=Regression.prototype.addObservation;Regression.prototype.calculateCoefficients=function(){var xTx=this.transposeOfXTimesX.product;var xTy=this.transposeOfXTimesY.product;var inv=inverse(xTx,this.identity);this.coefficients=multiply(inv,xTy);return this.coefficients};Regression.prototype.calculate=Regression.prototype.calculateCoefficients;Regression.prototype.hypothesize=function(options){if(!options)throw new Error("missing options");if(!(options.x instanceof Array))throw new Error("x property must be given as an array");if(!this.coefficients)this.calculateCoefficients();var hypothesis=[];for(var x=0;x<this.coefficients.length;x++){var coefficientRow=this.coefficients[x];for(var y=0;y<coefficientRow.length;y++)hypothesis[y]=(hypothesis[y]||0)+coefficientRow[y]*options.x[x]}return hypothesis};exports.MatrixProduct=MatrixProduct;exports.Regression=Regression;exports.multiply=multiply;function inverse(matrix,identity){var size=matrix.length;var result=new Array(size);for(var i=0;i<size;i++)result[i]=matrix[i].concat(identity[i]);result=rref(result);for(var i=0;i<size;i++)result[i].splice(0,size);return result}function identity(size){var matrix=squareMatrix({numRows:size,numColumns:size});for(var i=0;i<size;i++)matrix[i][i]=1;return matrix}function multiply(lhs,rhs){var options={numRows:lhs.length,numColumns:rhs[0].length};var streamingProduct=new MatrixProduct(options);for(var x=0;x<rhs.length;x++){var lhsColumn=[];for(var r=0;r<lhs.length;r++)lhsColumn.push(lhs[r][x]);var rhsRow=rhs[x];streamingProduct.addRowAndColumn({lhsColumn:lhsColumn,rhsRow:rhsRow})}return streamingProduct.product}function squareMatrix(options){var matrix=new Array(options.numRows);for(var r=0;r<options.numRows;r++){var row=new Array(options.numColumns);matrix[r]=row;for(var c=0;c<options.numColumns;c++){row[c]=0}}return matrix}},{rref:1}]},{},[2])(2)});
